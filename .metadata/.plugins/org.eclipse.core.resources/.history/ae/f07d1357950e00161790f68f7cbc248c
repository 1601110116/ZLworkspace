/*
 * CSPIC.cpp

 *
 *  Created on: 2016-4-18
 *      Author: lyt
 */
#include <CSPIC.h>

Grid* CSPIC::grid;
Vector3D ****CSPIC::curldA;
Vector3D ****CSPIC::curldTCurldA;

CSPIC::CSPIC(Grid *_grid){
	grid = _grid;
	init_3D_Vector_Field(curldA,grid->_width,grid->_height,grid->_length);
	init_3D_Vector_Field(curldTCurldA, grid->_width,grid->_height,grid->_length);
	std::cout << "CSPIC initialized" << std::endl;
}
CSPIC::~CSPIC(){

}

void CSPIC::iterate(const Range &range, double deltaT){
	updateP(range, deltaT);
#pragma omp barrier
	updateY(range, deltaT);
	updateX(range, deltaT);
	updateA(range, deltaT);
}


inline double _W1(double x){
	if (x > 2)
		return 0;
	else if (x > 1)
		return x * (Cube(x) * (x * (x * (x * (15.0/1024 * x - 15.0/128) + 49.0/128) - 21.0/32) + 35.0/64) - 1) + 1;
	else if (x > 0)
		return Square(x) * (Square(x) * (x * (x * (x * (-15.0/1024 * x - 15.0/128) + 7.0/16) - 21.0/32) + 175.0/256) - 105.0/128) + 337.0/512;
	else if (x > -1)
		return x * x * (x * x * (x * (x * (x * (-15.0/1024 * x + 15.0/128) + 7.0/16) + 21.0/32) + 175.0/256) - 105.0/128) + 337.0/512;
	else if (x > -2)
		return x * (Cube(x) * (x * (x * (x * (15.0/1024 * x + 15.0/128) + 49.0/128) + 21.0/32) + 35.0/64) + 1) + 1;
	else
		return 0;
	//	if (fabs(x) >= 1)
	//		return 0;
	//	else
	//		return 1-fabs(x);
}

inline double dW1(double x){
	if (x > 2)
		return 0;
	else if (x > 1)
		return Cube(x) * (x * (x * (x * (15.0/128 * x - 105.0/128) + 147.0/64) - 105.0/32) + 35.0/16) - 1;
	else if (x > 0)
		return x * (x * x * (x * (x * (x * (-15.0/128 * x - 105.0/128) + 21.0/8) - 105.0/32) + 175.0/64) - 105.0/64);
	else if (x > -1)
		return x * (x * x * (x * (x * (x * (-15.0/128 * x + 105.0/128) + 21.0/8) + 105.0/32) + 175.0/64) - 105.0/64);
	else if (x > -2)
		return Cube(x) * (x * (x * (x * (15.0/128 * x + 105.0/128) + 147.0/64) + 105.0/32) + 35.0/16) + 1;
	else
		return 0;
}

inline double _W(const Vector3D &r){
	return _W1(r.x)*_W1(r.y)*_W1(r.z);
}


inline void GradW(Vector3D& gradW, const Vector3D &r){
	gradW.x=dW1(r.x)*_W1(r.y)*_W1(r.z);
	gradW.y=_W1(r.x)*dW1(r.y)*_W1(r.z);
	gradW.z=_W1(r.x)*_W1(r.y)*dW1(r.z);
}

void CSPIC::rootOfLinearEquationSet(Vector3D& root, const Tensor3D &coefficient, const Vector3D &RHS){
	Tensor3D adjacentMatrix;
	double determinant = 0;

	adjacentMatrix.x.x = coefficient.y.y * coefficient.z.z - coefficient.y.z * coefficient.z.y;
	adjacentMatrix.x.y = -coefficient.x.y * coefficient.z.z + coefficient.x.z * coefficient.z.y;
	adjacentMatrix.x.z = coefficient.x.y * coefficient.y.z - coefficient.x.z * coefficient.y.y;
	adjacentMatrix.y.x = -coefficient.y.x * coefficient.z.z + coefficient.y.z * coefficient.z.x;
	adjacentMatrix.y.y = coefficient.x.x * coefficient.z.z - coefficient.x.z * coefficient.z.x;
	adjacentMatrix.y.z = -coefficient.x.x * coefficient.y.z + coefficient.x.z * coefficient.y.x;
	adjacentMatrix.z.x = coefficient.y.x * coefficient.z.y - coefficient.y.y * coefficient.z.x;
	adjacentMatrix.z.y = -coefficient.x.x * coefficient.z.y + coefficient.x.y * coefficient.z.x;
	adjacentMatrix.z.z = coefficient.x.x * coefficient.y.y - coefficient.x.y * coefficient.y.x;

	determinant += coefficient.x.x * adjacentMatrix.x.x;
	determinant += coefficient.y.x * adjacentMatrix.x.y;
	determinant += coefficient.z.x * adjacentMatrix.x.z;

	if (fabs(determinant) < 1e-16){
		std::cerr << "Coefficient Matrix is sigular, unable to find solution." << std::endl;
		std::cerr<<"Determinant: "<<determinant<<std::endl;
		//exit(0);
	}

#if OPTIMIZE
	adjacentMatrix/=determinant;

	root.x = adjacentMatrix.x * RHS;
	root.y = adjacentMatrix.y * RHS;
	root.z = adjacentMatrix.z * RHS;
#else
	Tensor3D inverseMatrix;

	inverseMatrix = adjacentMatrix/determinant;

	root.x = inverseMatrix.x * RHS;
	root.y = inverseMatrix.y * RHS;
	root.z = inverseMatrix.z * RHS;
#endif
}

void CSPIC::buidCoefficientTensor(Tensor3D& coefficientTensor,const Range &range, double deltaT, Particle *curParticle){
	coefficientTensor.restore();
	Vertex* curVertex;
	Vector3D colVector;
	Vector3D rowVector;
	Vector3D VertexRealPosition;
	Vector3D acceletor_D;
	for_each_Vertex_around(grid, curVertex, curParticle,VertexRealPosition){
#if OPTIMIZE
		acceletor_D=curParticle->Position;
		acceletor_D-=VertexRealPosition;
		GradW(colVector,acceletor_D);
#else
		GradW(colVector,curParticle->Position - VertexRealPosition);
#endif
		rowVector = curVertex->A*deltaT;
		coefficientTensor.x.x += colVector.x * rowVector.x;
		coefficientTensor.x.y += colVector.x * rowVector.y;
		coefficientTensor.x.z += colVector.x * rowVector.z;
		coefficientTensor.y.x += colVector.y * rowVector.x;
		coefficientTensor.y.y += colVector.y * rowVector.y;
		coefficientTensor.y.z += colVector.y * rowVector.z;
		coefficientTensor.z.x += colVector.z * rowVector.x;
		coefficientTensor.z.y += colVector.z * rowVector.y;
		coefficientTensor.z.z += colVector.z * rowVector.z;
	}end_for_each_Vertex_around
	coefficientTensor.x.x += 1;
	coefficientTensor.y.y += 1;
	coefficientTensor.z.z += 1;
}

void CSPIC::buildRHSVector(Vector3D &RHS,const Range &range, double deltaT, Particle *curParticle){
	RHS.restore();
	Vertex *curVertex1;
	Vertex *curVertex2;
	Vector3D Vertex1RealPosition,Vertex2RealPosition;
	Vector3D acceletor_GradW;
	for_each_Vertex_around(grid, curVertex1, curParticle,Vertex1RealPosition){
		for_each_Vertex_around(grid, curVertex2, curParticle,Vertex2RealPosition){

			GradW(acceletor_GradW, curParticle->Position - Vertex2RealPosition);
			acceletor_GradW *= _W(curParticle->Position - Vertex1RealPosition) * (curVertex1->A * curVertex2->A);
			RHS +=  acceletor_GradW;

			//RHS +=GradW(curParticle->Position - Vertex2RealPosition) * (_W(curParticle->Position - Vertex1RealPosition) * (curVertex1->A * curVertex2->A));
		}end_for_each_Vertex_around
	}end_for_each_Vertex_around
	RHS *= -deltaT;
	RHS +=curParticle->Momentum;
}

void CSPIC::updateP(const Range &range, double deltaT){
	Particle *curParticle;
	Tensor3D coefficient;    // The 3*3 coefficient matrix
	Vector3D RHS;                // Right hand side
	//Vector3D tmpV1;
	//Vector3D tmpV2;
	for_each_Particle_within(grid, curParticle, range){
		buidCoefficientTensor(coefficient, range, deltaT, curParticle);
		buildRHSVector(RHS, range, deltaT, curParticle);
		rootOfLinearEquationSet(curParticle->Momentum, coefficient, RHS);
	}end_for_each_Particle(curParticle)
}

//TODO: A lot of %!!

#define fastDecline1InLoop(i,loop) (i-1>=0?i-1:loop-1)
#define fastPlus1InLoop(i,loop) (i+1<loop?i+1:0)

Vector3D CSPIC::curld(Vector3D ****vectorField, int i, int j, int k){
	double Vx, Vy, Vz;
#if OPTIMIZE_1D
	Vx = (vectorField[i][j][k]->z - vectorField[i][fastDecline1InLoop(j,grid->_height)][k]->z)-(vectorField[i][j][k]->y - vectorField[i][j][fastDecline1InLoop(k,grid->_length)]->y);
	Vy = (vectorField[i][j][k]->x - vectorField[i][j][fastDecline1InLoop(k,grid->_length)]->x)-(vectorField[i][j][k]->z - vectorField[fastDecline1InLoop(i,grid->_width)][j][k]->z);
	Vz = (vectorField[i][j][k]->y - vectorField[fastDecline1InLoop(i,grid->_width)][j][k]->y)-(vectorField[i][j][k]->x - vectorField[i][fastDecline1InLoop(j,grid->_height)][k]->x);
#elif OPTIMIZE_3D
	Vx = (vectorField[i][j][k]->z - vectorField[i][fastDecline1InLoop(j,grid->_height)][k]->z)-(vectorField[i][j][k]->y - vectorField[i][j][fastDecline1InLoop(k,grid->_length)]->y);
	Vy = (vectorField[i][j][k]->x - vectorField[i][j][fastDecline1InLoop(k,grid->_length)]->x)-(vectorField[i][j][k]->z - vectorField[fastDecline1InLoop(i,grid->_width)][j][k]->z);
	Vz = (vectorField[i][j][k]->y - vectorField[fastDecline1InLoop(i,grid->_width)][j][k]->y)-(vectorField[i][j][k]->x - vectorField[i][fastDecline1InLoop(j,grid->_height)][k]->x);
#else
	Vx = (vectorField[i][j][k]->z - vectorField[i][(j-1+grid->_height)%grid->_height][k]->z)-(vectorField[i][j][k]->y - vectorField[i][j][(k-1+grid->_length)%grid->_length]->y);
	Vy = (vectorField[i][j][k]->x - vectorField[i][j][(k-1+grid->_length)%grid->_length]->x)-(vectorField[i][j][k]->z - vectorField[(i-1+grid->_width)%grid->_width][j][k]->z);
	Vz = (vectorField[i][j][k]->y - vectorField[(i-1+grid->_width)%grid->_width][j][k]->y)-(vectorField[i][j][k]->x - vectorField[i][(j-1+grid->_height)%grid->_height][k]->x);
#endif
	return Vector3D(Vx, Vy , Vz);
}

Vector3D CSPIC::curldT(Vector3D ****vectorField, int i, int j, int k){
	double Vx, Vy, Vz;
#if OPTIMIZE_1D
	Vx = (vectorField[i][fastPlus1InLoop(j,grid->_height)][k]->z - vectorField[i][j][k]->z)-(vectorField[i][j][fastPlus1InLoop(k,grid->_length)]->y - vectorField[i][j][k]->y);
	Vy = (vectorField[i][j][fastPlus1InLoop(k,grid->_length)]->x - vectorField[i][j][k]->x)-(vectorField[fastPlus1InLoop(i,grid->_width)][j][k]->z - vectorField[i][j][k]->z);
	Vz = (vectorField[fastPlus1InLoop(i,grid->_width)][j][k]->y - vectorField[i][j][k]->y)-(vectorField[i][fastPlus1InLoop(j,grid->_height)][k]->x - vectorField[i][j][k]->x);
#elif OPTIMIZE_3D
	Vx = (vectorField[i][fastPlus1InLoop(j,grid->_height)][k]->z - vectorField[i][j][k]->z)-(vectorField[i][j][fastPlus1InLoop(k,grid->_length)]->y - vectorField[i][j][k]->y);
	Vy = (vectorField[i][j][fastPlus1InLoop(k,grid->_length)]->x - vectorField[i][j][k]->x)-(vectorField[fastPlus1InLoop(i,grid->_width)][j][k]->z - vectorField[i][j][k]->z);
	Vz = (vectorField[fastPlus1InLoop(i,grid->_width)][j][k]->y - vectorField[i][j][k]->y)-(vectorField[i][fastPlus1InLoop(j,grid->_height)][k]->x - vectorField[i][j][k]->x);
#else
	Vx = (vectorField[i][(j+1)%grid->_height][k]->z - vectorField[i][j][k]->z)-(vectorField[i][j][(k+1)%grid->_length]->y - vectorField[i][j][k]->y);
	Vy = (vectorField[i][j][(k+1)%grid->_length]->x - vectorField[i][j][k]->x)-(vectorField[(i+1)%grid->_width][j][k]->z - vectorField[i][j][k]->z);
	Vz = (vectorField[(i+1)%grid->_width][j][k]->y - vectorField[i][j][k]->y)-(vectorField[i][(j+1)%grid->_height][k]->x - vectorField[i][j][k]->x);
#endif
	return Vector3D(Vx, Vy , Vz);
}

void CSPIC::setCurldA(const Range &range){
	int i, j, k;
	for (i = range.sx; i < range.ex; i++){
		for (j = range.sy; j < range.ey; j++){
			for (k = range.sz; k < range.ez; k++){
				*curldA[i][j][k] = CSPIC::curld(grid->A_indexer, i, j, k);
			}
		}
	}
}

void CSPIC::setCurldTCurldA(const Range &range){
	int i, j, k;
	for (i = range.sx; i < range.ex; i++){
		for (j = range.sy; j < range.ey; j++){
			for (k = range.sz; k < range.ez; k++){
				*curldTCurldA[i][j][k] = CSPIC::curldT(curldA, i, j, k);
			}
		}
	}
}

void CSPIC::updateY(const Range &range, double deltaT){
	Vector3D firstTerm;
	Vector3D secondTerm;
	Vertex *curVertex1;
	Vertex *curVertex2;
	Particle *curParticle;
	Vector3D Vertex2RealPosition,ParticleRealPosition;

	setCurldA(range);
	setCurldTCurldA(range);

	for_each_Vertex_within(grid, curVertex1, range){
		firstTerm = Vector3D();
		secondTerm = Vector3D();
		for_each_Particle_around(grid, curParticle, curVertex1,ParticleRealPosition){
			firstTerm += curParticle->Momentum * _W(curParticle->Position - curVertex1->_r);
			for_each_Vertex_around(grid, curVertex2, curParticle,Vertex2RealPosition){
				secondTerm += curVertex2->A * (_W(ParticleRealPosition - curVertex1->_r) * _W(ParticleRealPosition - Vertex2RealPosition));
			}end_for_each_Vertex_around
		}end_for_each_Particle_around(curParticle)
		curVertex1->Y += (firstTerm - secondTerm) * deltaT - *curldTCurldA[curVertex1->_x][curVertex1->_y][curVertex1->_z] * (Square(LIGHT_SPEED) * deltaT / (4 * M_PI));
	}end_for_each_Vertex_within
}

void CSPIC::updateX(const Range &range, double deltaT){
	Particle *curParticle;
	Vertex *curVertex;
	Vector3D secondTerm;
	Vector3D accelerator_A;
	Vector3D accelerator_P;
	Vector3D VertexRealPosition;
	for_each_Particle_within(grid, curParticle, range){
		secondTerm.restore();

		for_each_Vertex_around(grid, curVertex,curParticle, VertexRealPosition){
#if OPTIMIZE
			accelerator_A=curVertex->A;
			accelerator_A*=_W(curParticle->Position - VertexRealPosition);
			secondTerm += accelerator_A;
#else
			secondTerm += curVertex->A * _W(curParticle->Position - VertexRealPosition);
#endif
		}end_for_each_Vertex_around

#if OPTIMIZE
		accelerator_P=curParticle->Momentum;
		accelerator_P+=secondTerm;
		accelerator_P*=deltaT;

		curParticle->Position += accelerator_P;
#else
		curParticle->Position += (curParticle->Momentum + secondTerm) * deltaT;
#endif

	}end_for_each_Particle(curParticle)
}

void CSPIC::updateA(const Range &range, double deltaT){
	Vertex *curVertex;
	for_each_Vertex_within(grid, curVertex, range){
		curVertex->A += curVertex->Y * (deltaT / (FOUR_PI));
	}end_for_each_Vertex_within
}
